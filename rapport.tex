\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\title{Compilateur MiniC++ - analyseur syntaxique et analyseur grammatical}
\author{Corentin Cadiou, Ken Chanseau Saint-Germain}
\date{29 novembre 2013}
\begin{document}
\maketitle
\section*{Compiler le fichier}
Pour compiler le projet, la commande \texttt{make} réalise
automatiquement cette tâche. Elle créée un binaire \texttt{minic++}
dans le répertoire local. Pour nettoyer le répertoire local des
fichiers compilés et des fichiers temporaires, utiliser \texttt{make clean}.

Le binaire, qui est la première moitié du compilateur, réalise
l'analyse syntaxique et lexicale du fichier passé en argument. La
syntaxe d'utilisation de \texttt{minic++} est : \texttt{\$./minic++
  fichier-a-compiler.cpp}. Le compilateur ne renvoie rien dans le cas
d'une analyse syntaxique et lexicale sans erreur. Si une erreur est
détectée, la compilation s'arrête et renvoie un code d'erreur avec une
indication de la position de l'erreur.

\section*{Réalisation du projet}
Le compilateur a été réalisé en OCaml et utilise le générateur
d'analyseur syntaxique \texttt{ocamllex} (lexer) et l'analyseur grammatical
\texttt{menhir} (parser).

Le parser traduit les règles de syntaxe du langage en une fonction
qui prend un tampon d'analyse lexicale (ici, les caractères d'un
fichier) et renvoie une liste de jetons (tokens). Pour distinguer les
identificateurs des mots-clés et des identificateurs de classe, on
utilise une table de hachage contenant les mots-clés (keywords) et les
identificateurs de classe (tident).

L'analyseur grammatical (parser) traduit les règles de grammaire en
une fonction qui à un lexeur associe un arbre de syntaxe
abstraite. Notre analyseur grammatical utilise le module du lexeur
directement. On peut ainsi modifier dans le parseur la liste
des identificateurs de classe et réaliser le \emph{lexer hack}.

De plus, le parseur a résolu ses problèmes d'expansion/réduction
(shift/reduction) sur les opérateurs unaires en créant un jeton
abstrait de précédence différente et en utilisant le mot-clé
\texttt{\%prec} pour indiquer que les opérateurs unaires n'ont pas la
même précédence que les opérateurs binaires. De même, cette méthode a
été utilisée pour gérer la structure \texttt{if ... else ...}
\emph{via} un jeton abstrait \texttt{then}.
\pagebreak
\section*{Fichiers}
Le projet utilise les fichiers suivants :
\begin{itemize}
  \item \texttt{main.ml} : fichier principal qui ouvre le fichier à
    compiler et manipule le lexeur et le parseur;
  \item \texttt{lexer.mll} : règles de syntaxe utilisées par \texttt{ocamllex} pour
    compiler l'analyseur syntaxique;
  \item \texttt{parser.mly} : règles de grammaire et construction de l'arbre de
    syntaxe abstraite à l'aide de l'outil Menhir;
  \item \texttt{tokens.mly} : liste de jetons (tokens) utilisés par le parseur;
  \item \texttt{ast.mli} : structure de l'arbre de syntaxe abstraite;
  \item \texttt{Makefile} : fichier gérant la compilation, supporte les
    arguments \texttt{all} (optionnel) pour compiler Minic++ et \texttt{clean} pour
    nettoyer le répertoire des fichiers temporaires créés lors de la compilation.
\end{itemize}
  
\end{document}